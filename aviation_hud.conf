# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: Aviation 1.0
slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    shield:
        class: ShieldGeneratorUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual

handlers:
    unit:
        onStart:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
            
                
                system.showHelper(0)

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(1)
                
                --unit.hideWidget()
                -- Parenting widget
                parentingPanelId = system.createWidgetPanel("Docking")
                parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
                system.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)

                -- Combat stress widget
                coreCombatStressPanelId = system.createWidgetPanel("Core combat stress")
                coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,"core_stress")
                system.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                --core.showWidget()
                core.hideWidget()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.showWidget() end
                if warpdrive ~= nil then warpdrive.showWidget() end
                if gyro ~= nil then gyro.showWidget() end
                if shield ~= nil then shield.showWidget() end

                -- freeze the player in he is remote controlling the construct
                if unit.isRemoteControlled() == 1 then
                    player.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end
                
                --PIDS
                rollPID = pid.new(0.1, 0, 1)
                pitchPID = pid.new(0.1, 0, 1)

                verticalInput = 0
                
                flightMode = false
                holdAltitude = false
                --desiredAltitude = core.getAltitude()
                
                
        onStop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hideWidget() end
                if warpdrive ~= nil then warpdrive.hideWidget() end
                if gyro ~= nil then gyro.hideWidget() end
                core.hideWidget()
                unit.switchOffHeadlights()

    system:
        onFlush:
            lua: |
                if flightMode then
                    -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                    local pitchSpeedFactor = 1 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                    local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                    local rollSpeedFactor = 1 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                    local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                    local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                    local autoRoll = true --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                    local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                    local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                    local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                    local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                    -- validate params
                    pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                    yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                    rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                    torqueFactor = math.max(torqueFactor, 0.01)
                    brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                    brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                    autoRollFactor = math.max(autoRollFactor, 0.01)
                    turnAssistFactor = math.max(turnAssistFactor, 0.01)

                    -- final inputs
                    local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                    local finalRollInput = rollInput + system.getControlDeviceYawInput()
                    local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                    local finalBrakeInput = brakeInput

                    -- Axis
                    local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                    local constructUp = vec3(construct.getWorldOrientationUp())
                    local constructForward = vec3(construct.getWorldOrientationForward())
                    local constructRight = vec3(construct.getWorldOrientationRight())
                    local constructVelocity = vec3(construct.getWorldVelocity())
                    local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                    local currentRollDegAbs = math.abs(currentRollDeg)
                    local currentRollDegSign = utils.sign(currentRollDeg)

                    if holdAltitude then
                        local desiredPitch = utils.clamp((desiredAltitude - core.getAltitude()) / constructVelocity:len(),-10,10)
                        local currentPitch = angle_between(worldVertical,constructForward) * constants.rad2deg - 90
                        pitchPID:inject(desiredPitch - currentPitch)
                        finalPitchInput = pitchPID:get()
                        
                    end

                    -- Rotation
                    local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                    local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                    + finalRollInput * rollSpeedFactor * constructForward
                                                    + finalYawInput * yawSpeedFactor * constructUp

                    -- In atmosphere?
                    if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                        local autoRollRollThreshold = 1.0
                        -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                        if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                            local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                            if (rollPID == nil) then
                                rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                            end
                            rollPID:inject(targetRollDeg - currentRollDeg)
                            local autoRollInput = rollPID:get()

                            targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                        end
                        local turnAssistRollThreshold = 20.0
                        -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                        if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                            local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                            local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                            -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                            local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                            local rollVerticalRatio = 0
                            if rescaleRollDegAbs < 90 then
                                rollVerticalRatio = rescaleRollDegAbs / 90
                            elseif rescaleRollDegAbs < 180 then
                                rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                            end

                            rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                            local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                            local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                            targetAngularVelocity = targetAngularVelocity
                                                + turnAssistPitchInput * constructRight
                                                + turnAssistYawInput * constructUp
                        end
                    end

                    -- Engine commands
                    local keepCollinearity = 1 -- for easier reading
                    local dontKeepCollinearity = 0 -- for easier reading
                    local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                    -- Rotation
                    local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                    local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                    angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                    Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                    -- Brakes
                    local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                    Nav:setEngineForceCommand('brake', brakeAcceleration)

                    -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                    local autoNavigationEngineTags = ''
                    local autoNavigationAcceleration = vec3()
                    local autoNavigationUseBrake = false

                    -- Longitudinal Translation
                    local longitudinalEngineTags = 'thrust analog longitudinal'
                    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                    if (longitudinalCommandType == axisCommandType.byThrottle) then
                        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                        Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                    elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                        if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                            Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                        then
                            autoNavigationUseBrake = true
                        end

                    end

                    -- Lateral Translation
                    local lateralStrafeEngineTags = 'thrust analog lateral'
                    local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                    if (lateralCommandType == axisCommandType.byThrottle) then
                        local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                        Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                    elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                        local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                    end

                    -- Vertical Translation
                    local verticalStrafeEngineTags = 'thrust analog vertical'
                    local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                    if (verticalCommandType == axisCommandType.byThrottle) then
                        local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                        Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                    elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                        local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                        autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                    end

                    -- Auto Navigation (Cruise Control)
                    if (autoNavigationAcceleration:len() > constants.epsilon) then
                        if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                        then
                            autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                        end
                        Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                    end

                    -- Rockets
                    Nav:setBoosterCommand('rocket_engine')
                else
                    local pitchMax = 40 --export
                    local rollMax = 20 --export
                    
                    --Reassign Inputs
                    local stabPitchInput = pitchInput --pith
                    local stabYawInput = rollInput --yaw
                    local stabRollInput = yawInput --roll
                    
                    local desiredPitch = utils.sign(stabPitchInput)*pitchMax
                    local desiredRoll = utils.sign(stabRollInput)*rollMax
                    
                    -- Reassign Axis
                    local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                    local worldGravity = vec3(core.getWorldGravity())
                    local constructUp = vec3(construct.getWorldOrientationForward())
                    local constructForward = -vec3(construct.getWorldOrientationUp())
                    local constructRight = vec3(construct.getWorldOrientationRight())
                    local constructVelocity = vec3(construct.getWorldVelocity())
                    local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()

                    --local currentAltitude = core.getAltitude()
                    
                    local currentPitch = angle_between(worldVertical,constructForward) * constants.rad2deg - 90
                    pitchPID:inject(desiredPitch-currentPitch)
                    local finalPitchInput = pitchPID:get()
                    
                    local currentRoll = getRoll(worldVertical, constructForward, constructRight)
                    rollPID:inject(desiredRoll-currentRoll)
                    local finalRollInput = rollPID:get()
                    
                    local finalYawInput = stabYawInput

                    -- Rotation
                    local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                    local targetAngularVelocity = finalPitchInput * constructRight
                                                    + finalRollInput * constructForward
                                                    + finalYawInput * constructUp

                    local angularAcceleration = targetAngularVelocity - constructAngularVelocity
                    local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                    Nav:setEngineTorqueCommand('torque', angularAcceleration - airAcceleration, 1, 'airfoil', '', '', 1)
                    
                    local finalVerticalInput = verticalInput
                    local acceleration = finalVerticalInput*(-worldVertical) - worldGravity

                    -- Engine
                    Nav:setEngineForceCommand('thrust analog longitudinal, thrust analog lateral, thrust analog vertical', acceleration, 0, '', '', '', 1)
                    if stabPitchInput == 0 and  stabRollInput == 0 and verticalInput == 0 then
                        local brakeAcceleration = -constructVelocityDir * 10000
                        Nav:setEngineForceCommand('brake', brakeAcceleration)
                    end
                    
                end

        onUpdate:
            lua: |
                Nav:update()
                if flightMode then
                    AviationHud:update()
                else
                    system.setScreen('')
                end

        onActionStart:
            args: [option1]
            lua: |
                if flightMode then
                    flightMode = false
                else
                    flightMode = true
                end

        onActionStart:
            args: [option6]
            lua: |
                if holdAltitude then
                    holdAltitude = false
                else
                    holdAltitude = true
                    desiredAltitude = utils.round(core.getAltitude())
                end

        onActionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    unit.deployLandingGears()
                else
                    unit.retractLandingGears()
                end

        onActionStart:
            args: [light]
            lua: |
                if unit.isAnyHeadlightSwitchedOn() == 1 then
                    unit.switchOffHeadlights()
                else
                    unit.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        onActionStop:
            args: [forward]
            lua: pitchInput = 0
        onActionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        onActionStop:
            args: [backward]
            lua: pitchInput = 0
        onActionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        onActionStop:
            args: [left]
            lua: rollInput = 0
        onActionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        onActionStop:
            args: [right]
            lua: rollInput = 0

        onActionStart:
            args: [straferight]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
                end
        onActionStop:
            args: [straferight]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)
                end

        onActionStart:
            args: [strafeleft]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
                end
        onActionStop:
            args: [strafeleft]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)
                end

        onActionStart:
            args: [up]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
                    verticalInput = 0
                else
                    verticalInput = 1
                end
        onActionStop:
            args: [up]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                else
                    verticalInput = 0
                end
        onActionLoop:
            args: [up]
            lua: |
                if flightMode and holdAltitude then
                    desiredAltitude = desiredAltitude + 1
                end    
        onActionStart:
            args: [down]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
                    verticalInput = 0
                else
                    verticalInput = -1
                end
        onActionStop:
            args: [down]
            lua: |
                if flightMode then
                    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
                else
                    verticalInput = 0
                end
        onActionLoop:
            args: [down]
            lua: |
                if flightMode and holdAltitude then
                    desiredAltitude = desiredAltitude - 1
                end    
        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        onActionStop:
            args: [yawright]
            lua: yawInput = 0
        onActionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        onActionStop:
            args: [yawleft]
            lua: yawInput = 0
        onActionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                if flightMode then
                    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                    if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                        local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                        if (math.abs(targetSpeed) > constants.epsilon) then
                            Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                        end
                    end
                end
        onActionStop:
            args: [brake]
            lua: brakeInput = 0

        onActionLoop:
            args: [brake]
            lua: |
                if flightMode then 
                    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                    if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                        local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                        if (math.abs(targetSpeed) > constants.epsilon) then
                            Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                        end
                    end
                end
        onActionStart:
            args: [booster]
            lua: if flightMode then Nav:toggleBoosters() end
        onActionStart:
            args: [stopengines]
            lua: if flightMode then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) end
        onActionStart:
            args: [speedup]
            lua: if flightMode then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0) end
        onActionLoop:
            args: [speedup]
            lua: if flightMode then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0) end
        onActionStart:
            args: [speeddown]
            lua: if flightMode then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0) end
        onActionLoop:
            args: [speeddown]
            lua: if flightMode then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0) end
        onActionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end

    library:
        onStart:
            lua: |
            -- instead of standard function
            function angle_between(vector1,vector2)
                return math.acos(utils.clamp(vector1:dot(vector2) / (vector1:len() * vector2:len()),-1,1))
            end
            
            local MarkClass = {}
            function MarkClass:new(a,b,c,d,e,f,g,h,i,j)local function k(a,c,d)local l='<g id="'..a..'"'if d and d~=1 then l=l..' transform="scale('..d..')"'end;return l..'>'..c..'</g>'end;local m={id=a or error("mark id must be specified"),step=b or 10,markCode=k(a,c,d),numberShiftX=e or 0,numberShiftY=f or 0,numberSize=g or 0,numberColor=h or"#ffffff",numberAnchor=i or"middle",isFixNumberPosition=j or false}local n={}function n:getStep()return m.step end;local function o(p,q,r,s,t)local p=p or 0;local q=q or 1;local s=s or 0;local l='<g transform="translate(0,'..p..')">'if t then l=l..'<use xlink:href="#'..m.id..'" opacity="'..q..'"/>'else l=l..m.markCode end;if m.numberSize>0 then l=l..'<text x="'..m.numberShiftX..'" y="'..m.numberShiftY..'"'if m.isFixNumberPosition then l=l..' transform="rotate('..s..',0,0)"'end;l=l..'" style="fill:'..m.numberColor..';stroke-width:0px;text-anchor:'..m.numberAnchor..';font-size:'..m.numberSize..';fill-opacity:'..q..';">'..r..'</text>'end;return l..'</g>'end;function n:drawTemplate()return m.markCode end;function n:drawMark(p,q,r,s)return o(p,q,r,s)end;function n:drawMarkCopy(p,q,r,s)return o(p,q,r,s,true)end;self.__index=self;return setmetatable(n,self)end

            local LadderHudClass = {}
            function LadderHudClass:new(a,b,c,d,e,f,g,h,i,j,k)local function l(a,b,f)local f=f or"#ffffff"return'<g transform="translate('..a..','..b..')" style="fill:none;stroke:'..f..';stroke-width:2px;">'end;local m={length=c or 100,range=d or 100,rotation=g or 0,radius=h or 0,rangeStart=i,rangeEnd=j,isMirrored=k or false,markArray=e or nil,headerText=l(a,b,f),footerText='</g>'}local n={}function n:draw(o,g)if not e then return end;local p=m.headerText;p=p..'<decs>'local d=m.range;local q=d/2;local r={}local s=nil;for t,u in pairs(e)do p=p..u:drawTemplate()local v=u:getStep()if v>0 then local w=o%v;if o<0 then w=w-v end;local x=utils.round(q,v)for y=-x,x,v do local z=utils.round(y+w,0.01)if math.abs(z)<q then r[z]=u end end else s=u end end;p=p..'</decs>'local A=m.rotation;if g then A=A+g end;p=p..'<g transform="rotate('..A..',0,0)">'for z,u in pairs(r)do local B=z/q;local C=utils.round((1-B*B)*0.8+0.01,0.01)local D=utils.round(o-z,u:getStep())if m.rangeStart and m.rangeEnd then local E=utils.map(D,m.rangeStart,m.rangeEnd,0,1)local F=E%1;if m.isMirrored then local G=E%2;if F~=G then F=1-F end end;D=utils.round(utils.map(F,0,1,m.rangeStart,m.rangeEnd))end;if m.radius==0 then p=p..u:drawMarkCopy(B*m.length,C,D,-m.rotation)else local H=B*m.length;p=p..'<g transform="rotate('..H..','..-m.radius..',0)">'..u:drawMarkCopy(0,C,D,-m.rotation-H)..'</g>'end end;if s then local I=utils.round(o)p=p..s:drawMarkCopy(0,0.6,I,-m.rotation)end;return p..'</g>'..m.footerText end;self.__index=self;return setmetatable(n,self)end

            local AviationHudClass = {}

            --@param core - the global core
            --@param unit - the global unit
            --@param sizeX - size of the HUD
            --@param sizeY - size of the HUD
            --@param color - color of the HUD
            --@param shadowColor - shadow color of the HUD
            --@return AviationHudClass

            function AviationHudClass:new(core, unit, system, construct, scale, color, shadowColor)

                local simplifyHude = false --export: Remove intermediate graduation lines.<br>Valid values: true or false
                local verticalVelocityThreshold = 10 --export: vertical velocity threshold to show the vertical velocity. From 0 to positive
                local driftThreshold = 10 --export: drift threshold to show the drift. From 0 to positive

                local privateObj = {
                    core = core,
                    unit = unit,
                    system = system,
                    construct = construct,
                    showHud = true,
                    scale = scale or 1,
                    color = color or "#ffffff",
                    shadowColor = shadowColor or "#000000"
                }

                --local lineMiddle40 = '<path d="m-20 0 h40"/>'
                --local lineMiddle60 = '<path d="m-30 0 h60"/>'
                --local lineMiddle80 = '<path d="m-40 0 h80"/>'
                --local lineMiddle120 = '<path d="m-60 0 h120"/>'
                local lineMiddle200 = '<path d="m-100 0 h200"/>'
                local lineLeft10 = '<path d="m0 0 h10"/>'
                local lineLeft15 = '<path d="m0 0 h15"/>'
                local lineLeft15Shift15 = '<path d="m15 0 h15"/>'
                local lineLeft30 = '<path d="m0 0 h30"/>'
                local lineLeft60 = '<path d="m0 0 h60"/>'
                local horizonStatic = '<path d="m-180 3 v-6 h20 l10 3 -10 3 z m360 0 v-6 h-20 l-10 3 10 3 z"/>'
                local delta10LeftShift60 = '<path d="m60 0 l10 -10 v20 z"/>'
                local delta10LeftShift30 = '<path d="m30 0 l10 -10 v20 z"/>'
                local delta10Right = '<path d="m0 0 l-10 10 v-20 z"/>'
                local lineDouble20Width300 = '<path d="m-150 0 h20 m260 0 h20"/>'
                local lineDouble30Width300 = '<path d="m-150 0 h30 m240 0 h30"/>'
                local lineDouble40Width300 = '<path d="m-150 0 h40 m220 0 h40"/>'

                --MarkClass:new(id, step, markCode, markScale, numberShiftX, numberShiftY, numberSize, numberColor, numberAnchor, isTurnNumberWithMark)
                --local markLineMiddle40Step2d5NoText = MarkClass:new("LineMiddle40Step2d5NoText", 2.5, lineMiddle40)
                local markLineDouble20Width300Step2d5NoText = MarkClass:new("LineDouble20Width300Step2d5NoText", 2.5, lineDouble20Width300)
                --local markLineMiddle60Step5NoText = MarkClass:new("LineMiddle60Step5NoText", 5, lineMiddle60)
                local markLineDouble30Width300Step5NoText = MarkClass:new("Double30Width300Step5NoText", 5, lineDouble30Width300)
                --local markLineMiddle80Step10Text = MarkClass:new("LineMiddle80Step10Text", 10, lineMiddle80, 1, -45, 5, 20, privateObj.color, "end")
                local markLineDouble40Width300Step10Text = MarkClass:new("LineDouble40Width300Step10Text", 10, lineDouble40Width300, 1, -105, 5, 20, privateObj.color, "start")
                local markLineMiddle200Step360NoText = MarkClass:new("LineMiddle200Step360NoText", 360, lineMiddle200, 1.5)

                --local markLineLeft15Step2d5NoText = MarkClass:new("LineLeft12d5Step2d5NoText", 2.5, lineLeft15)
                local markLineLeft10Step2d5NoText = MarkClass:new("LineLeft12d5Step2d5NoText", 2.5, lineLeft10)
                local markLineLeft15Step1NoText = MarkClass:new("LineLeft15Step1NoText", 1, lineLeft15)
                local markLineLeft15Shift15Step1NoText = MarkClass:new("LineLeft15Shift15Step1NoText", 1, lineLeft15Shift15)
                local markLineLeft30Step5NoText = MarkClass:new("LineLeft30Step5NoText", 5, lineLeft30)
                local markLineLeft30Step5TextLeft = MarkClass:new("LineLeft30Step5Text", 5, lineLeft30, 1, -5, 5, 20, privateObj.color, "end")
                local markLineLeft30Step5TextRight = MarkClass:new("LineLeft30Step5Text", 5, lineLeft30, 1, 35, 5, 20, privateObj.color, "start")
                local markLineLeft60Step10Text1 = MarkClass:new("LineLeft60Step10Text", 10, lineLeft60, 1, 0, 15, 20, privateObj.color, "middle", true)
                --local markLineLeft60Step10Text2 = MarkClass:new("LineLeft60Step10Text", 10, lineLeft60, 1, 0, -10, 20, privateObj.color, "middle", true)
                local markLineLeft15Step10Text = MarkClass:new("LineLeft15Step10Text", 10, lineLeft15, 1, 0, -5, 20, privateObj.color, "middle", true)

                --local markDelta10Shift60Text = MarkClass:new("Delta10Shift60Text", 0, delta10LeftShift60, 1, 0, -75, 20, privateObj.color, "middle", false)
                local markDelta10Shift60NoText = MarkClass:new("Delta10Shift60Text", 0, delta10LeftShift60)
                local markDelta10Shift30NoText = MarkClass:new("Delta10Shift30NoText", 0, delta10LeftShift30)
                local markDelta10RightNoText = MarkClass:new("Delta10RightNoText", 0, delta10Right)
                
                local markHorizonStatic = MarkClass:new("HorizonStatic", 0, horizonStatic)

                --LadderHudClass:new(centerX, centerY, length, range, markArray, color, rotation, radius, rangeStart, rangeEnd, isMirrored)
                local function getPitchLadder(color)
                    local color = color --change to "#ffffff" to customize the color
                    local mark2d5 = markLineDouble20Width300Step2d5NoText
                    local mark5 = markLineDouble30Width300Step5NoText
                    local mark10 = markLineDouble40Width300Step10Text
                    local horizon = markLineMiddle200Step360NoText
                    local horizonStatic = markHorizonStatic
                    local markArray = {mark2d5,mark5,mark10,horizon,horizonStatic}
                    if simplifyHude then markArray = {mark10,horizon,horizonStatic} end
                    return LadderHudClass:new(0, 0, 200, 50, markArray, color, 0, 0, -90, 90, true)
                end

                local function getRollLadder(color)
                    local color = color --change to "#ffffff" to customize the color
                    local mark5 = markLineLeft30Step5NoText
                    local mark10 = markLineLeft60Step10Text1
                    local staticMark = markDelta10Shift60NoText
                    local markArray = {mark5,mark10,staticMark}
                    if simplifyHude then markArray = {mark10,staticMark} end
                    return LadderHudClass:new(0, -300, 50, 50, markArray, color, -90, 400, 0, 180, true)
                end

                local function getYawLadder(color)
                    local color = color --change to "#ffffff" to customize the color
                    local mark2d5 = markLineLeft10Step2d5NoText
                    --local mark5 = markLineLeft30Step5NoText
                    local mark10 = markLineLeft15Step10Text
                    local staticMark = markDelta10Shift60NoText
                    local markArray = {mark2d5,mark10,staticMark}
                    if simplifyHude then markArray = {mark10,staticMark} end
                    return LadderHudClass:new(0, 300, 200, 50, markArray, color, 90, 0, 0, 360, false)
                end

                local function getSpeedLadder(color)
                    local color = color --change to "#ffffff" to customize the color
                    local mark1 = markLineLeft15Shift15Step1NoText
                    local mark5 = markLineLeft30Step5TextLeft
                    local staticMark = markDelta10Shift30NoText
                    local markArray = {mark1,mark5,staticMark}
                    if simplifyHude then markArray = {mark5,staticMark} end
                    return LadderHudClass:new(-400, 0, 200, 20, markArray, color)
                end

                local function getAltitudeLadder(color)
                    local color = color --change to "#ffffff" to customize the color
                    local mark1 = markLineLeft15Step1NoText
                    local mark5 = markLineLeft30Step5TextRight
                    local staticMark = markDelta10RightNoText
                    local markArray = {mark1,mark5,staticMark}
                    if simplifyHude then markArray = {mark5,staticMark} end
                    return LadderHudClass:new(400, 0, 200, 20, markArray, color)
                end

                privateObj.pitchLadder = getPitchLadder(privateObj.color)
                privateObj.rollLadder = getRollLadder(privateObj.color)
                privateObj.yawLadder = getYawLadder(privateObj.color)
                privateObj.speedLadder = getSpeedLadder(privateObj.color)
                privateObj.altitudeLadder = getAltitudeLadder(privateObj.color)
                
                local function drawNumberWithArrow(number,threshold,showSign,horizontalShift,verticalShift,arrowPositive,arrowNegative,color,scale)
                    local number = number or 0
                    local threshold = threshold or 1  
                    if number > -threshold and number < threshold then
                        return ""
                    end

                    local horizontalShift = horizontalShift or 0
                    local verticalShift = verticalShift or 0
                    local scale = scale or 1
                    local color = color or "#ffffff"
                    
                    local arrow = ""
                    if number > 0 then -- arrow up
                        arrow = arrowPositive or ""
                    else -- arrow down
                        arrow = arrowNegative or ""
                    end
                    
                    if not showSign then
                        number = math.abs(number)
                    end
                    
                    return '<g transform="scale(' ..scale.. ') translate('..horizontalShift..','..verticalShift..')" style="fill:none;stroke:'..color..';stroke-width:2px;opacity:0.8;"><text y="14" style="fill:'..color..';stroke-width:0px;text-anchor:middle;font-size:20;fill-opacity:0.8;">'..number..'</text>'..arrow..'</g>'    
                end

                function privateObj:drawVerticalVelocity(velocity)
                    local arrowUp = '<path d="m-10-5h20l-10-10z"/>'
                    local arrowDown = '<path d="m-10 21h20l-10 10z"/>'
                    --drawNumberWithArrow(number,threshold,showSign,horizontalShift,verticalShift,arrowPositive,arrowNegative,color,scale)
                    return drawNumberWithArrow(velocity,verticalVelocityThreshold,false,300,0,arrowUp,arrowDown,privateObj.color,1)
                end

                function privateObj:drawDriftVelocity(velocity)
                    local arrowRight = '<path d="m0-5v-20l20 10z"/>'
                    local arrowLeft = '<path d="m0 -5v-20l-20 10z"/>'
                    --drawNumberWithArrow(number,threshold,showSign,horizontalShift,verticalShift,arrowPositive,arrowNegative,color,scale)
                    return drawNumberWithArrow(velocity,driftThreshold,false,-300,0,arrowRight,arrowLeft,privateObj.color,1)
                end

                function privateObj:drawVelocityShpere(cx,cy,x,y,z,colorMain,colorVector,scale,opacity,ellipseX,ellipseY)
                    local cx = cx or 0
                    local cy = cy or 0
                    local x = x * 100 or 0
                    local y = y * 100 or 0
                    local z = z * 100 or 0
                    local colorMain = colorMain or "#ffffff"
                    local colorVector = colorVector or "#ff0000"
                    local scale = scale or 1
                    local opacity = opacity or 0.6
                    local relativeOpacity = utils.round(opacity/3,0.01)
                    local ellipseX = ellipseX or 0.2
                    local ellipseY = ellipseY or 0.2
                    local relX = x+z*ellipseX
                    local relY = y+z*ellipseY
                    
                    return '<defs><circle id="c" r="100" stroke="'..colorMain..'" stroke-width="1" /></defs><g transform="translate('..cx..' '..cy..') scale('..scale..')" stroke="'..colorMain..'" stroke-width="1" opacity="'..opacity..'"><use xlink:href="#c" stroke-width="2" fill="'..colorMain..'" fill-opacity="'..utils.round(opacity/10,0.01)..'" /><use xlink:href="#c" transform="scale(1 '..ellipseY..')" fill="none" /><use xlink:href="#c" transform="scale('..ellipseX..' 1)" fill="none" /><path d="M0,0l20-20" /><path d="M0,0l-20,20" opacity="'..relativeOpacity..'" /><path d="M0,0h100" /><path d="M0,0h-100" opacity="'..relativeOpacity..'" /><path d="M0,0v-100" /><path d="M0,0v100" opacity="'..relativeOpacity..'" /><path d="M0,0l'..relX..' '..-relY..'" stroke="'..colorVector..'" stroke-width="2" /><use xlink:href="#c" transform="translate('..relX..' '..-relY..') scale(0.03)" fill="'..colorVector..'" /></g>'
                end

                function privateObj:drawVelocityMark(sx,sy,x,y,z,colorMain,colorMark,markScale,opacity)
                    local sx = sx or 1400
                    local sy = sy or 800
                    local x = x or 0
                    local y = y or 0
                    local z = z or 0
                    local colorMain = colorMain or "#ffffff"
                    local colorMark = colorMark or "#ff0000"
                    local markScale = markScale or 1
                    local opacity = opacity or 0.3
                    
                    if z < 0 then colorMark = "none" end
                    
                    return '<g stroke="'..colorMain..'" stroke-width="1" opacity="'..opacity..'"><path d="M'..-sx..','..-y*sy..'h'..sx*2 ..'"/><path d="M'..x*sx..','.. -sy ..'v'..sy*2 ..'" /><circle r="'..sy/50 ..'" cx="'..x*sx..'" cy="'..-y*sy..'" fill="'..colorMark..'"/></g>'
                end

                local publicObj = {}

                function publicObj:toggleHud()
                    privateObj.showHud = not privateObj.showHud
                    system.setScreen("")
                end

                function publicObj:update()
                    if not privateObj.showHud then return end
                    
                    local core = privateObj.core
                    local unit = privateObj.unit
                    local system = privateObj.system
                    local construct = privateObj.construct

                    local worldVertical = vec3(core.getWorldVertical())
                    local worldGravity = vec3(core.getWorldGravity()):len()

                    --autopilot message
                    local message = 'Aviation Hud v1.0'

                    if worldGravity > 0.1 then
                        -- aero view
                        local atmosphereDensity = unit.getAtmosphereDensity()
                        local constructAltitude = core.getAltitude()
                        
                        local constructUp = vec3(construct.getWorldOrientationUp())
                        local constructForward = vec3(construct.getWorldOrientationForward())
                        local constructRight = vec3(construct.getWorldOrientationRight())
                        local constructVelocity = vec3(construct.getWorldVelocity())
                        
                        local hudPitch = angle_between(worldVertical,constructForward) * constants.rad2deg - 90
                        local hudRoll = -getRoll(worldVertical, constructForward, constructRight)
                        
                        local north = vec3(0, 0, 1)
                        local hudYaw = -getRoll(north, constructUp, constructRight)
                        
                        local totalVelocity = constructVelocity:len() * 3.6

                        local function getScalarProject(vec,toVec)
                            local vecProject = vec:project_on(toVec)
                            local vecScalar = vecProject:len()
                            local angle = angle_between(toVec,vecProject)
                            if angle > math.pi / 2 then vecScalar = -vecScalar end
                            return vecScalar
                        end
                        
                        local verticalVelocity = getScalarProject(constructVelocity,worldVertical) * 3.6
                        local driftVelocity = getScalarProject(constructVelocity,constructRight) * 3.6
                        local constructVelocityNormalized = constructVelocity:normalize()
                        local velocityForward = getScalarProject(constructVelocityNormalized,constructForward)
                        local velocityRight = getScalarProject(constructVelocityNormalized,constructRight)
                        local velocityUp = getScalarProject(constructVelocityNormalized,constructUp)

                        --local throttle = unit.getThrottle()

                        local hudWidth = 1400 * privateObj.scale
                        local hudHeight = 800 * privateObj.scale
                        local hudWidthCenter = hudWidth/2
                        local hudHeightCenter = hudHeight/2
                        
                        local velocityMark = ""
                        if atmosphereDensity < 0.01 and totalVelocity > 10 then
                            velocityMark = privateObj:drawVelocityMark(hudWidth,hudHeight,velocityRight,velocityUp,velocityForward)
                        end

                        local hudHtml = '<div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;">'
                        .. '<svg style="width:' .. hudWidth .. ';height:' .. hudHeight .. ';filter:drop-shadow(0 0 2px '..privateObj.shadowColor..');">'
                        .. '<g transform="translate(' .. hudWidthCenter .. ',' .. hudHeightCenter .. ') scale('..privateObj.scale..')">'
                        .. privateObj.pitchLadder:draw(hudPitch, hudRoll)
                        .. privateObj.rollLadder:draw(hudRoll)
                        .. privateObj.yawLadder:draw(hudYaw)
                        .. privateObj.speedLadder:draw(totalVelocity)
                        .. privateObj.altitudeLadder:draw(constructAltitude)
                        .. privateObj:drawVelocityShpere(-550,-250,velocityRight,velocityUp,velocityForward)
                        .. velocityMark
                        .. privateObj:drawDriftVelocity(utils.round(driftVelocity))
                        .. privateObj:drawVerticalVelocity(-utils.round(verticalVelocity))
                        .. '</g>'
                        .. '</svg></div>'
                        ..message
                        
                        system.setScreen(hudHtml)
                    else
                        -- space view
                        system.setScreen(message)
                    end

                end

                -- don't delete this
                self.__index = self
                return setmetatable(publicObj, self)
            end

            local hudScale = 1 --export: HUD scale.<br>Valid values: positive number
            local hudColor = "#ffffff" --export: Main color for the HUD
            local hudShadowColor = "#000000" --export: Shadow color for the HUD

            AviationHud = AviationHudClass:new(core, unit, system, construct, hudScale, hudColor, hudShadowColor)
            system.showScreen(1)
